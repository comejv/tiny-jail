name: Rust Release

on:
  push:
    branches: ["main"]

env:
  CARGO_TERM_COLOR: always
  RUSTFLAGS: "-C strip=symbols"

jobs:
  release:
    name: Release on minor/major version bump
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y libseccomp-dev jq

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry + target
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: cargo-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            cargo-${{ runner.os }}-

      - name: Get package name and version from Cargo.toml
        id: cargo_meta
        shell: bash
        run: |
          set -euo pipefail
          if command -v cargo >/dev/null 2>&1; then
            pkg_name=$(cargo metadata --no-deps --format-version=1 \
              | jq -r '.packages[0].name')
            version=$(cargo metadata --no-deps --format-version=1 \
              | jq -r '.packages[0].version')
          else
            pkg_name=$(grep -m1 '^name\s*=' Cargo.toml | cut -d '"' -f 2)
            version=$(grep -m1 '^version\s*=' Cargo.toml | cut -d '"' -f 2)
          fi
          echo "name=$pkg_name" >> "$GITHUB_OUTPUT"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "tag=v$version" >> "$GITHUB_OUTPUT"

      - name: Determine previous version (semantic latest tag)
        id: prev_version
        shell: bash
        run: |
          set -euo pipefail
          git fetch --tags --prune
          previous_tag=$(git tag --sort=-v:refname \
            | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' \
            | head -n 1 || true)
          if [ -z "${previous_tag:-}" ]; then
            echo "No previous semver tag found; assuming 0.0.0"
            echo "previous_version=0.0.0" >> "$GITHUB_OUTPUT"
            echo "previous_tag=" >> "$GITHUB_OUTPUT"
          else
            previous_version="${previous_tag#v}"
            echo "Found previous tag: $previous_tag (version: $previous_version)"
            echo "previous_version=$previous_version" >> "$GITHUB_OUTPUT"
            echo "previous_tag=$previous_tag" >> "$GITHUB_OUTPUT"
          fi

      - name: Check if version has changed
        id: version_check
        shell: bash
        run: |
          set -euo pipefail
          current_version="${{ steps.cargo_meta.outputs.version }}"
          previous_version="${{ steps.prev_version.outputs.previous_version }}"

          if [ "$current_version" = "$previous_version" ]; then
            echo "⏭️  Version unchanged ($current_version). Skipping release."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
          else
            echo "✅ Version changed: $previous_version → $current_version"
            echo "should_release=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Compute previous ref for changelog
        id: changelog_base
        if: ${{ steps.version_check.outputs.should_release == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ steps.prev_version.outputs.previous_tag }}" ]; then
            echo "base_ref=${{ steps.prev_version.outputs.previous_tag }}" >> "$GITHUB_OUTPUT"
          else
            root=$(git rev-list --max-parents=0 HEAD | tail -n 1)
            echo "base_ref=$root" >> "$GITHUB_OUTPUT"
          fi

      - name: Run tests
        if: ${{ steps.version_check.outputs.should_release == 'true' }}
        run: |
          set -euo pipefail
          cargo build --locked --release --bin audisp-plugin
          cargo test --locked --verbose

      - name: Build release binary
        if: ${{ steps.version_check.outputs.should_release == 'true' }}
        id: build
        shell: bash
        run: |
          set -euo pipefail
          cargo build --locked --release --bin audisp-plugin
          cargo build --locked --release
          BIN="${{ steps.cargo_meta.outputs.name }}"
          SRC="target/release/${BIN}"
          if [ ! -f "$SRC" ]; then
            echo "Expected binary $SRC not found. If workspace/multiple bins, adjust selection."
            exit 1
          fi

          OS="linux"
          ARCH="$(uname -m)"
          VERSION="${{ steps.cargo_meta.outputs.version }}"
          ASSET_NAME="${BIN}-v${VERSION}-${OS}-${ARCH}.tar.gz"

          tmpdir="$(mktemp -d)"
          install -Dm755 "$SRC" "$tmpdir/$BIN"
          [ -f LICENSE ] && cp LICENSE "$tmpdir/"
          [ -f README.md ] && cp README.md "$tmpdir/"
          tar -C "$tmpdir" -czf "$ASSET_NAME" .

          echo "asset_name=${ASSET_NAME}" >> "$GITHUB_OUTPUT"
          echo "asset_path=${ASSET_NAME}" >> "$GITHUB_OUTPUT"

      - name: Ensure tag exists (create or move tag to current HEAD)
        if: ${{ steps.version_check.outputs.should_release == 'true' }}
        id: ensure_tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.cargo_meta.outputs.tag }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git ls-remote --tags origin | grep -q "refs/tags/${tag}$"; then
            echo "Tag ${tag} exists on origin. Re-pointing it to HEAD of main."
            git tag -d "${tag}" || true
            git push origin ":refs/tags/${tag}" || true
          else
            echo "Tag ${tag} does not exist on origin. Will create."
          fi

          git tag -a "${tag}" -m "Release ${tag}"
          git push origin "${tag}"

      - name: Create or get GitHub Release for tag
        if: ${{ steps.version_check.outputs.should_release == 'true' }}
        id: upsert_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          owner_repo="${{ github.repository }}"
          tag="${{ steps.cargo_meta.outputs.tag }}"
          api="https://api.github.com/repos/${owner_repo}"

          body_text=$(printf 'Release %s\n\nChanges:\n%s\n' \
            "$tag" \
            "**Full Changelog**: https://github.com/${owner_repo}/compare/v${{ steps.prev_version.outputs.previous_version }}...v${{ steps.cargo_meta.outputs.version }}")

          get_resp=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" \
            "${api}/releases/tags/${tag}" || true)

          if echo "$get_resp" | jq -e '.id' >/dev/null 2>&1; then
            release_id=$(echo "$get_resp" | jq -r '.id')
            upload_url=$(echo "$get_resp" | jq -r '.upload_url' | sed 's/{?name,label}//')
            echo "Found existing release id=${release_id} for ${tag}"

            patch_payload=$(jq -n --arg body "$body_text" '{body: $body}')
            curl -sS -X PATCH \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$patch_payload" \
              "${api}/releases/${release_id}" >/dev/null
          else
            echo "No release for ${tag}. Creating..."
            payload=$(jq -n \
              --arg tag_name "$tag" \
              --arg target "${{ github.ref_name }}" \
              --arg name "$tag" \
              --arg body "$body_text" \
              '{
                tag_name: $tag_name,
                target_commitish: $target,
                name: $name,
                body: $body,
                draft: false,
                prerelease: false
              }')

            create_resp=$(curl -sS -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$payload" \
              "${api}/releases")

            release_id=$(echo "$create_resp" | jq -r '.id')
            upload_url=$(echo "$create_resp" | jq -r '.upload_url' | sed 's/{?name,label}//')

            if [ "$release_id" = "null" ] || [ -z "$release_id" ]; then
              echo "Failed to create release: $create_resp"
              exit 1
            fi
            echo "Created release id=${release_id} for ${tag}"
          fi

          {
            echo "release_id=$release_id"
            echo "upload_url=$upload_url"
          } >> "$GITHUB_OUTPUT"

      - name: Remove existing asset with same name (if any)
        if: ${{ steps.version_check.outputs.should_release == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          owner_repo="${{ github.repository }}"
          release_id="${{ steps.upsert_release.outputs.release_id }}"
          asset_name="${{ steps.build.outputs.asset_name }}"
          api="https://api.github.com/repos/${owner_repo}"

          assets=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" \
            "${api}/releases/${release_id}/assets")

          existing_id=$(echo "$assets" \
            | jq -r ".[] | select(.name==\"${asset_name}\") | .id")

          if [ -n "${existing_id:-}" ] && [ "$existing_id" != "null" ]; then
            echo "Deleting existing asset ${asset_name} (id=${existing_id})"
            curl -sS -X DELETE -H "Authorization: token $GITHUB_TOKEN" \
              "${api}/releases/assets/${existing_id}" >/dev/null
          else
            echo "No existing asset named ${asset_name}."
          fi

      - name: Upload asset to release
        if: ${{ steps.version_check.outputs.should_release == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          upload_url="${{ steps.upsert_release.outputs.upload_url }}"
          asset_path="${{ steps.build.outputs.asset_path }}"
          asset_name="${{ steps.build.outputs.asset_name }}"

          curl -sS \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Content-Type: application/gzip" \
            --data-binary @"${asset_path}" \
            "${upload_url}?name=$(basename "${asset_name}")"
